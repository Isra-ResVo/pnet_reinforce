import torch


def pointer_mask(
    step, kwargs, main_mask, main_selection, steps_qnt, device
) -> torch.Tensor:
    r"""
    This mask and the others modify the state of the amin mask to avoid choose
    elements previously choosen.

    """

    # El valor de true en las máscara solo detenrmina que ese  valor será enmascarado
    cloud_number = -2  # Deja fuera posiciones (k_position, stop_position)
    k_position = -2
    stop_idx = -1

    # las primera dos iteciones solo esta abilitadad la seleccion de nubes
    if step < 2:
        mask_clouds = torch.zeros_like(main_mask)
        mask_clouds[:, cloud_number:] = 1
        mask_condition = mask_clouds + main_mask
    # se bloquea solo la k porque no puede haber una k>n
    elif step < 3:
        mask_clouds = torch.zeros_like(main_mask)
        mask_clouds[:, cloud_number] = 1  # bloquea la k
        mask_condition = mask_clouds + main_mask

    else:
        # Todo este bloque actua como un condicional, primero bloquea k sí está
        #   llega a ser mayor que la cantidad de nubes seleccionadas (1)
        #   posteriormente al resultado anterior se llega a bloquear por completo si
        #   ha aparecido previamente el  simbolo de paro (2).

        # (1) Determina la cantidad de nubes y k, hasta i.
        # obteniendo los datos relevantes de las mascaras.
        selections = torch.stack(main_selection, dim=1)  # [batch,steps_secuenfce]
        qnt_k = torch.sum((selections == steps_qnt - 2), dim=1)
        qnt_stop = torch.sum((selections == steps_qnt - 1), dim=1)
        qnt_clouds = step - (qnt_k + qnt_stop)

        condition_k_present = qnt_k > 0
        block_q = torch.zeros_like(main_mask).to(device)
        block_q[:, :k_position] = 1
        mask_condition = torch.where(
            condition_k_present.reshape(-1, 1), block_q, main_mask
        )
        # print( "controlando la cantidad de k aquí solo deben de estar las nubes habilitado para k menor a n \n{}".format(mask_condition[:10]))

        # (2) Bloquea todas las selecciones y solo deja el caracter de relleno.
        #     -Para bloquear la k si esta llega a ser mayor que n.
        condition_k = qnt_k + 2 < qnt_clouds
        stop_condition = main_mask[:, stop_idx:].type(
            torch.bool
        ) + ~condition_k.reshape(
            -1, 1
        )  # bool values
        mask_all = torch.zeros_like(main_mask).to(device)
        mask_all[:, :stop_idx] = 1
        mask_condition = torch.where(stop_condition, mask_all, mask_condition).type(
            torch.bool
        )

    return mask_condition


def mask_n(step, kwargs, main_mask, main_selection, steps_qnt, device) -> torch.Tensor:
    r"""
    (1) First only let the clouds be choosing  in accordance  of
    n_elements (this is generated by the user) then if this condition
    is meet.

    (2) k is choose  when strictly is < n,  if k == n  then only q will
    be open for be take or if q apper  before that k == n then the secuence
    over and only "q" will be choosen.
    """
    cloud_number = -2  # Deja fuera posiciones (k_position, stop_position)
    stop_idx = -1
    if step <= 1:
        mask_kn = torch.zeros_like(main_mask).to(device)
        mask_kn[:, cloud_number:] = 1

        mask_condition = main_mask + mask_kn

    else:

        # gettting states of main_mask
        selections = torch.stack(main_selection, dim=1)  # [batch,steps_secuenfce]

        qnt_k = torch.sum((selections == steps_qnt - 2), dim=1)
        qnt_stop = torch.sum((selections == steps_qnt - 1), dim=1)
        qnt_clouds = step - (qnt_k + qnt_stop)

        # (1) Only selection of clouds
        cloud_cond = (qnt_clouds >= kwargs["restricted_n"]).reshape(-1, 1)
        mask_clouds = torch.zeros_like(main_mask, dtype=torch.int64).to(device)
        mask_clouds[:, :cloud_number] = 1

        mask_extra = torch.zeros_like(main_mask, dtype=torch.int64).to(device)
        mask_extra[:, cloud_number:] = 1  # ????? revisar este

        mask_clouds = torch.where(cloud_cond, mask_clouds, mask_extra)
        mask_withOutK = main_mask
        mask_withOutK[:, -2] = 0
        mask_condition = mask_clouds + mask_withOutK

        # (2) k selection with k <= n and q condition
        k_condition = (qnt_k + 2) >= kwargs["restricted_n"]

        q_condition = main_mask[:, stop_idx].type(torch.bool)
        condition_qk = (k_condition + q_condition).reshape(-1, 1)  # k or q (bool)

        mask_qk = torch.ones_like(main_mask).to(device)
        mask_qk[:, stop_idx] = 0  # only stop condition available

        mask_condition = torch.where(condition_qk, mask_qk, mask_condition)

    return mask_condition.type(torch.bool)


def mask_k(step, kwargs, main_mask, main_selection, steps_qnt, device) -> torch.Tensor:
    # This function permits to have minimum k clouds and C clouds (all the batch elements)

    stop_idx = -1
    # Validation k elements greater or equal to 2
    allElementsGreaterEqual2 = torch.any(kwargs["restricted_k"] >= 2)
    if not allElementsGreaterEqual2:
        raise ValueError("invalid k paramer")

    if step <= 1:  # Take minimum 2 elements in the batch
        mask_stopElement = torch.zeros_like(main_mask, device=device)
        mask_stopElement[:, stop_idx] = 1

        mask_condition = main_mask + mask_stopElement

    else:
        mask_stopElement = torch.zeros_like(main_mask, device=device)
        mask_stopElement[:, stop_idx] = 1
        maskPlusBlockStop = main_mask + mask_stopElement

        stopByItemsSelected = (
            step >= kwargs["restricted_k"]
        )  # This allows to grab items with minimum requirement of k items previosly selected.

        # mask that block  the stopElement  if  n < k
        mask_condition = torch.where(
            stopByItemsSelected.reshape(-1, 1), main_mask, maskPlusBlockStop
        )  # (condition, if true, else)

        conditionStopElement = main_mask[:, stop_idx].type(torch.bool).reshape(-1, 1)

        mask_clouds = torch.ones_like(main_mask, device=device)
        mask_clouds[:, -1] = 0

        mask_condition = torch.where(conditionStopElement, mask_clouds, mask_condition)

    return mask_condition.type(torch.bool)
